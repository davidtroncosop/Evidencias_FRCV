{"file_contents":{"main.py":{"content":"import streamlit as st\nimport gspread\nfrom google.oauth2.service_account import Credentials\nfrom google.cloud import storage\nimport pandas as pd\nfrom datetime import datetime\nimport json\nimport os\nimport io\nimport urllib.parse\n\n# Definición de criterios de acreditación\nCRITERIOS_ACREDITACION = {\n    \"I. DIMENSIÓN DOCENCIA Y RESULTADOS DEL PROCESO FORMATIVO\": {\n        \"Criterio 1. Modelo educativo y diseño curricular\":\n        \"La formulación del modelo educativo define las características y objetivos de los programas. El diseño e implementación curricular se orienta por procedimientos institucionales que guían el desarrollo de los programas conducentes a títulos y grados académicos.\",\n        \"Criterio 2. Procesos y resultados de enseñanza y aprendizaje\":\n        \"El diseño e implementación de los programas de enseñanza y aprendizaje provee las condiciones necesarias para el logro del perfil de egreso por parte de los estudiantes, en los distintos niveles, programas y modalidades.\",\n        \"Criterio 3. Cuerpo académico\":\n        \"El cuerpo académico cuenta con la dedicación y credenciales académicas y profesionales para el desarrollo del proceso de enseñanza y aprendizaje de toda la oferta educativa.\",\n        \"Criterio 4. Investigación, innovación docente y mejora del proceso formativo\":\n        \"La universidad emprende y desarrolla acciones de investigación y/o innovación sobre su experiencia docente que impactan positivamente en el proceso formativo, en lo disciplinar y en lo pedagógico, de acuerdo con el proyecto institucional.\"\n    },\n    \"II. DIMENSIÓN GESTIÓN ESTRATÉGICA Y RECURSOS INSTITUCIONALES\": {\n        \"Criterio 5. Gobierno y estructura organizacional\":\n        \"La universidad cuenta con un sistema de gobierno y una estructura organizacional que le permiten gestionar todas las funciones institucionales conforme a su misión, visión, propósitos y tamaño.\",\n        \"Criterio 6. Gestión y desarrollo de personas\":\n        \"La universidad posee y aplica mecanismos para los procesos de reclutamiento, selección, inducción, desarrollo profesional, evaluación y retiro.\",\n        \"Criterio 7. Gestión de la convivencia, equidad de género, diversidad e inclusión\":\n        \"La universidad promueve el desarrollo integral de su comunidad en todo su quehacer y responde en su gestión a los desafíos en materia de convivencia, equidad de género, respeto a la diversidad e inclusión.\",\n        \"Criterio 8. Gestión de recursos\":\n        \"La universidad cuenta con los medios necesarios para el desarrollo de sus actividades, así como con políticas y mecanismos para la gestión de los recursos operativos y económicos.\"\n    },\n    \"III. DIMENSIÓN ASEGURAMIENTO INTERNO DE LA CALIDAD\": {\n        \"Criterio 9. Gestión y resultados del aseguramiento interno de la calidad\":\n        \"La universidad define, implementa, monitorea y optimiza su sistema interno de aseguramiento de la calidad.\",\n        \"Criterio 10. Aseguramiento de la calidad de los programas formativos\":\n        \"La institución dispone y aplica normativa o procedimientos vigentes para la mejora continua de sus procesos de formación, en todos los programas conducentes a títulos y grados académicos.\"\n    },\n    \"IV. DIMENSIÓN VINCULACIÓN CON EL MEDIO\": {\n        \"Criterio 11. Política y gestión de la vinculación con el medio\":\n        \"La función de vinculación con el medio es bidireccional, es decir, una construcción conjunta de la universidad con sus grupos relevantes de interés.\",\n        \"Criterio 12. Resultados e impacto de la vinculación con el medio\":\n        \"La universidad realiza acciones de vinculación con el medio que tienen un impacto positivo en su entorno significativo o a nivel nacional, y en la formación de los estudiantes.\"\n    },\n    \"V. DIMENSIÓN INVESTIGACIÓN, CREACIÓN Y/O INNOVACIÓN\": {\n        \"Criterio 13. Política y gestión de la investigación, creación y/o innovación\":\n        \"La investigación, creación y/o innovación están presentes de manera explícita en la misión y propósitos declarados por la universidad.\",\n        \"Criterio 14. Resultados de la investigación, creación y/o innovación\":\n        \"La universidad obtiene resultados de investigación, creación y/o innovación que generan impacto en el medio interno o externo (académico, cultural, servicios, productivo o social).\"\n    }\n}\n\n# Configuración de la página\nst.set_page_config(\n    page_title=\"Sistema de Evidencias - Acreditación Universitaria\",\n    page_icon=\"📚\",\n    layout=\"wide\")\n\n\n# Función para inicializar Google Sheets\n@st.cache_resource\ndef init_google_sheets():\n    \"\"\"Inicializa la conexión con Google Sheets usando las credenciales de los secrets\"\"\"\n    try:\n        # Obtener credenciales desde los secrets de Replit\n        google_credentials = os.getenv(\"GOOGLE_SHEETS_CREDENTIALS\")\n        if not google_credentials:\n            st.error(\n                \"No se encontraron las credenciales de Google Sheets en los secrets\"\n            )\n            return None\n\n        # Parsear las credenciales JSON\n        creds_dict = json.loads(google_credentials)\n\n        # Configurar los scopes necesarios\n        scopes = [\n            \"https://www.googleapis.com/auth/spreadsheets\",\n            \"https://www.googleapis.com/auth/drive\"\n        ]\n\n        # Crear las credenciales\n        credentials = Credentials.from_service_account_info(creds_dict,\n                                                            scopes=scopes)\n\n        # Inicializar el cliente de gspread\n        client = gspread.authorize(credentials)\n\n        return client\n    except Exception as e:\n        st.error(f\"Error al inicializar Google Sheets: {str(e)}\")\n        return None\n\n\n# Función para inicializar Google Cloud Storage\n@st.cache_resource\ndef init_google_cloud_storage():\n    \"\"\"Inicializa la conexión con Google Cloud Storage usando las credenciales de los secrets\"\"\"\n    try:\n        # Usar las mismas credenciales que Google Sheets\n        google_credentials = os.getenv(\"GOOGLE_SHEETS_CREDENTIALS\")\n        if not google_credentials:\n            st.error(\n                \"No se encontraron las credenciales de Google en los secrets\")\n            return None\n\n        # Parsear las credenciales JSON\n        creds_dict = json.loads(google_credentials)\n\n        # Configurar los scopes necesarios para Storage\n        scopes = [\n            \"https://www.googleapis.com/auth/cloud-platform\",\n            \"https://www.googleapis.com/auth/devstorage.full_control\"\n        ]\n\n        # Crear las credenciales con los scopes correctos\n        credentials = Credentials.from_service_account_info(creds_dict,\n                                                            scopes=scopes)\n\n        # Inicializar el cliente de Google Cloud Storage con credenciales explícitas\n        client = storage.Client(credentials=credentials,\n                                project=creds_dict.get('project_id'))\n\n        return client\n    except Exception as e:\n        st.error(f\"Error al inicializar Google Cloud Storage: {str(e)}\")\n        return None\n\n\n# Función para obtener usuarios desde Google Sheets\n@st.cache_data(ttl=300)  # Cache por 5 minutos\ndef get_users_data(_client):\n    \"\"\"Obtiene los datos de usuarios desde la hoja de Google Sheets\"\"\"\n    try:\n        # Abrir la hoja de cálculo\n        sheet = _client.open(\"sistema_evidencias\")\n\n        # Obtener la pestaña de usuarios\n        usuarios_worksheet = sheet.worksheet(\"usuarios\")\n\n        # Obtener todos los datos\n        data = usuarios_worksheet.get_all_records()\n\n        return pd.DataFrame(data)\n    except Exception as e:\n        st.error(f\"Error al obtener datos de usuarios: {str(e)}\")\n        return pd.DataFrame()\n\n\n# Función para obtener evidencias desde Google Sheets\n@st.cache_data(ttl=60)  # Cache por 1 minuto\ndef get_evidencias_data(_client):\n    \"\"\"Obtiene los datos de evidencias desde la hoja de Google Sheets\"\"\"\n    try:\n        # Abrir la hoja de cálculo\n        sheet = _client.open(\"sistema_evidencias\")\n\n        # Obtener la pestaña de evidencias\n        evidencias_worksheet = sheet.worksheet(\"evidencias\")\n\n        # Obtener todos los datos\n        data = evidencias_worksheet.get_all_records()\n\n        return pd.DataFrame(data)\n    except Exception as e:\n        st.error(f\"Error al obtener datos de evidencias: {str(e)}\")\n        return pd.DataFrame()\n\n\n# Función para agregar nueva evidencia\ndef add_evidencia(client, programa, subido_por, url_cloudinary, criterio,\n                  dimension, nombre_archivo):\n    \"\"\"Agrega una nueva evidencia a la hoja de Google Sheets\"\"\"\n    try:\n        # Abrir la hoja de cálculo\n        sheet = client.open(\"sistema_evidencias\")\n\n        # Obtener la pestaña de evidencias\n        evidencias_worksheet = sheet.worksheet(\"evidencias\")\n\n        # Crear nueva fila con los datos\n        fecha_hora = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        new_row = [\n            programa, subido_por, url_cloudinary, fecha_hora, criterio,\n            dimension, nombre_archivo\n        ]\n\n        # Agregar la fila\n        evidencias_worksheet.append_row(new_row)\n\n        return True\n    except Exception as e:\n        st.error(f\"Error al agregar evidencia: {str(e)}\")\n        return False\n\n\ndef upload_to_gcs(file,\n                  folder_name,\n                  gcs_client,\n                  dimension=None,\n                  criterio=None,\n                  bucket_name=None):\n    \"\"\"Sube un archivo a Google Cloud Storage y retorna la URL pública\"\"\"\n    try:\n        # Lista de buckets a intentar (en orden de preferencia)\n        bucket_options = []\n\n        if bucket_name:\n            bucket_options.append(bucket_name)\n\n        # Opciones de nombres de bucket basados en el proyecto\n        project_id = gcs_client.project\n        bucket_options.extend([\n            \"mi-bucket-proyecto\",\n            \"n8n-integracion-gdrive-evidencias\",\n            f\"{project_id}-evidencias\",\n            f\"{project_id}-storage\",\n            f\"evidencias-{project_id}\",\n        ])\n\n        # Intentar encontrar un bucket que exista\n        working_bucket = None\n        for bucket_name_attempt in bucket_options:\n            try:\n                bucket = gcs_client.bucket(bucket_name_attempt)\n                # Verificar si existe haciendo una operación simple\n                bucket.reload()\n                working_bucket = bucket\n                actual_bucket_name = bucket_name_attempt\n                st.success(f\"✅ Usando bucket: {actual_bucket_name}\")\n                break\n            except Exception as e:\n                st.warning(\n                    f\"Bucket {bucket_name_attempt} no disponible: {str(e)}\")\n                continue\n\n        if not working_bucket:\n            # Listar buckets disponibles para ayudar al usuario\n            st.error(\"No se encontró ningún bucket disponible\")\n            try:\n                buckets = list(gcs_client.list_buckets())\n                if buckets:\n                    st.write(\"Buckets disponibles en tu proyecto:\")\n                    for b in buckets:\n                        st.write(f\"- {b.name}\")\n                    st.info(\n                        \"Puedes usar uno de estos buckets modificando el código\"\n                    )\n                else:\n                    st.error(\n                        \"No hay buckets creados en tu proyecto. Necesitas crear uno manualmente.\"\n                    )\n                    st.info(\n                        \"Ve a https://console.cloud.google.com/storage y crea un bucket\"\n                    )\n            except Exception as list_error:\n                st.error(f\"Error al listar buckets: {str(list_error)}\")\n            return None\n\n        # Crear la ruta del archivo con estructura de carpetas\n        # Limpiar nombres para que sean compatibles con GCS\n        clean_dimension = dimension.replace(\"/\", \"-\").replace(\n            \"\\\\\", \"-\").replace(\".\", \"_\") if dimension else \"\"\n        clean_criterio = criterio.replace(\"/\", \"-\").replace(\"\\\\\", \"-\").replace(\n            \".\", \"_\") if criterio else \"\"\n        clean_folder = folder_name.replace(\"/\",\n                                           \"-\").replace(\"\\\\\",\n                                                        \"-\").replace(\".\", \"_\")\n\n        # Crear la ruta: programa/dimension/criterio/archivo\n        if dimension and criterio:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            file_name_clean = file.name.replace(\" \",\n                                                \"_\").replace(\"/\", \"-\").replace(\n                                                    \"\\\\\", \"-\")\n            file_path = f\"{clean_folder}/{clean_dimension}/{clean_criterio}/{timestamp}_{file_name_clean}\"\n        else:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            file_name_clean = file.name.replace(\" \",\n                                                \"_\").replace(\"/\", \"-\").replace(\n                                                    \"\\\\\", \"-\")\n            file_path = f\"{clean_folder}/{timestamp}_{file_name_clean}\"\n\n        # Crear el blob (archivo en GCS)\n        blob = working_bucket.blob(file_path)\n\n        # Subir el archivo\n        file.seek(0)  # Resetear el puntero del archivo\n        blob.upload_from_file(file, content_type=file.type)\n        st.success(f\"Archivo subido exitosamente: {file_path}\")\n\n        # Generar URL pública\n        try:\n            # Intentar hacer el archivo público\n            blob.make_public()\n            st.success(f\"Archivo hecho público exitosamente. URL: {blob.public_url}\")\n            return blob.public_url\n            \n        except Exception as e:\n            # Si make_public() falla por cualquier razón, ahora lo sabremos\n            st.error(f\"❌ No se pudo hacer el archivo público. Causa: {str(e)}\")\n            st.warning(\"El archivo fue subido, pero no se pudo generar un enlace público.\")\n            st.info(\"Verifica la configuración de 'Acceso detallado' en los permisos del bucket.\")\n            # Devolvemos None porque no pudimos generar la URL que queríamos\n            return None\n\n    except Exception as e:\n        st.error(f\"Error al subir {file.name}: {str(e)}\")\n        return None\n\n\n# Función de autenticación\ndef authenticate_user(email, password, users_df):\n    \"\"\"Autentica al usuario con email y contraseña y retorna sus datos\"\"\"\n    if users_df.empty:\n        return None\n\n    user_data = users_df[users_df['correo'].str.lower() == email.lower()]\n\n    if not user_data.empty:\n        # Verificar contraseña (si no existe columna contraseña, permitir acceso)\n        stored_password = user_data.iloc[0].get('contraseña', password)\n        if stored_password == password:\n            return {\n                'correo': user_data.iloc[0]['correo'],\n                'programa': user_data.iloc[0]['programa'],\n                'rol': user_data.iloc[0]['rol']\n            }\n    return None\n\n\n# Función para mostrar el login\ndef show_login():\n    \"\"\"Muestra la pantalla de login\"\"\"\n    st.title(\"🔐 Iniciar Sesión\")\n    st.write(\"Sistema de Gestión de Evidencias de Acreditación Universitaria\")\n\n    with st.form(\"login_form\"):\n        email = st.text_input(\"Correo electrónico\",\n                              placeholder=\"usuario@universidad.edu\")\n        password = st.text_input(\"Contraseña\",\n                                 type=\"password\",\n                                 placeholder=\"Ingresa tu contraseña\")\n        submit_button = st.form_submit_button(\"Iniciar Sesión\")\n\n        if submit_button:\n            if not email or not password:\n                st.error(\n                    \"Por favor ingrese su correo electrónico y contraseña\")\n                return\n\n            # Inicializar Google Sheets\n            client = init_google_sheets()\n            if not client:\n                return\n\n            # Obtener datos de usuarios\n            users_df = get_users_data(client)\n            if users_df.empty:\n                st.error(\"No se pudieron cargar los datos de usuarios\")\n                return\n\n            # Autenticar usuario\n            user_data = authenticate_user(email, password, users_df)\n\n            if user_data:\n                st.session_state.user_data = user_data\n                st.session_state.logged_in = True\n                st.success(f\"¡Bienvenido! Ingresando como {user_data['rol']}\")\n                st.rerun()\n            else:\n                st.error(\"Correo o contraseña incorrectos\")\n\n\n# Función para cambiar contraseña\ndef change_password_page():\n    \"\"\"Página para cambiar contraseña\"\"\"\n    st.title(\"🔐 Cambiar Contraseña\")\n\n    with st.form(\"change_password_form\"):\n        current_password = st.text_input(\"Contraseña actual\", type=\"password\")\n        new_password = st.text_input(\"Nueva contraseña\", type=\"password\")\n        confirm_password = st.text_input(\"Confirmar nueva contraseña\",\n                                         type=\"password\")\n        submit_button = st.form_submit_button(\"Cambiar Contraseña\")\n\n        if submit_button:\n            if not all([current_password, new_password, confirm_password]):\n                st.error(\"Por favor complete todos los campos\")\n                return\n\n            if new_password != confirm_password:\n                st.error(\"Las contraseñas nuevas no coinciden\")\n                return\n\n            if len(new_password) < 6:\n                st.error(\n                    \"La nueva contraseña debe tener al menos 6 caracteres\")\n                return\n\n            # Inicializar Google Sheets\n            client = init_google_sheets()\n            if not client:\n                st.error(\"Error al conectar con la base de datos\")\n                return\n\n            # Obtener datos de usuarios\n            users_df = get_users_data(client)\n            if users_df.empty:\n                st.error(\"No se pudieron cargar los datos de usuarios\")\n                return\n\n            # Verificar contraseña actual\n            user_email = st.session_state.user_data['correo']\n            user_data = authenticate_user(user_email, current_password,\n                                          users_df)\n\n            if not user_data:\n                st.error(\"Contraseña actual incorrecta\")\n                return\n\n            # Actualizar contraseña en Google Sheets\n            try:\n                worksheet = client.open(\"sistema_evidencias\").worksheet(\n                    \"usuarios\")\n                all_records = worksheet.get_all_records()\n\n                # Encontrar la fila del usuario\n                for i, record in enumerate(all_records):\n                    if str(record['correo']).lower() == user_email.lower():\n                        row_num = i + 2  # +2 porque las filas empiezan en 1 y hay encabezado\n\n                        # Verificar si existe la columna contraseña\n                        headers = worksheet.row_values(1)\n                        if 'contraseña' not in headers:\n                            # Agregar columna contraseña si no existe\n                            worksheet.update_cell(1,\n                                                  len(headers) + 1,\n                                                  'contraseña')\n                            col_num = len(headers) + 1\n                        else:\n                            col_num = headers.index('contraseña') + 1\n\n                        # Actualizar contraseña\n                        worksheet.update_cell(row_num, col_num, new_password)\n                        st.success(\"✅ Contraseña actualizada exitosamente\")\n\n                        # Limpiar cache para recargar datos\n                        get_users_data.clear()\n                        return\n\n                st.error(\"Usuario no encontrado\")\n\n            except Exception as e:\n                st.error(f\"Error al actualizar contraseña: {str(e)}\")\n\n\n# Función mejorada para eliminar archivo de Google Cloud Storage\ndef delete_from_gcs(file_url,\n                    gcs_client,\n                    bucket_name=\"n8n-integracion-gdrive-evidencias\"):\n    \"\"\"Elimina un archivo de Google Cloud Storage usando su URL\"\"\"\n    try:\n        if not file_url:\n            st.warning(\"URL del archivo vacía\")\n            return False\n\n        # Múltiples métodos para extraer el path del archivo\n        file_path = None\n\n        # Método 1: URL de la API de Storage\n        if \"/storage/v1/b/\" in file_url:\n            try:\n                parts = file_url.split(\"/storage/v1/b/\")[1].split(\"/o/\")\n                if len(parts) > 1:\n                    file_path = parts[1].split(\"?\")[0]\n                    file_path = urllib.parse.unquote(file_path)\n            except:\n                pass\n\n        # Método 2: URL pública googleapis.com\n        if not file_path and \"googleapis.com\" in file_url:\n            try:\n                if f\"storage.googleapis.com/{bucket_name}/\" in file_url:\n                    file_path = file_url.split(\n                        f\"storage.googleapis.com/{bucket_name}/\")[1].split(\n                            \"?\")[0]\n                    file_path = urllib.parse.unquote(file_path)\n            except:\n                pass\n\n        # Método 3: URL con patrón /bucket/file\n        if not file_path and bucket_name in file_url:\n            try:\n                # Buscar el bucket en la URL y extraer lo que viene después\n                bucket_index = file_url.find(bucket_name)\n                if bucket_index != -1:\n                    remaining = file_url[bucket_index + len(bucket_name):]\n                    if remaining.startswith(\"/\"):\n                        remaining = remaining[1:]  # Quitar el slash inicial\n                    file_path = remaining.split(\"?\")[\n                        0]  # Quitar parámetros de query\n                    file_path = urllib.parse.unquote(file_path)\n            except:\n                pass\n\n        # Método 4: URL firmada (signed URL)\n        if not file_path and \"/o/\" in file_url:\n            try:\n                o_index = file_url.find(\"/o/\")\n                if o_index != -1:\n                    remaining = file_url[o_index + 3:]  # +3 para \"/o/\"\n                    file_path = remaining.split(\"?\")[0]\n                    file_path = urllib.parse.unquote(file_path)\n            except:\n                pass\n\n        if not file_path:\n            st.error(\n                f\"No se pudo extraer la ruta del archivo desde la URL: {file_url}\"\n            )\n            st.error(\n                \"Patrones buscados: /storage/v1/b/, googleapis.com, bucket name, /o/\"\n            )\n            return False\n\n        st.info(f\"Intentando eliminar archivo: {file_path}\")\n\n        # Obtener el bucket y eliminar el archivo\n        bucket = gcs_client.bucket(bucket_name)\n        blob = bucket.blob(file_path)\n\n        if blob.exists():\n            blob.delete()\n            st.success(\n                f\"Archivo eliminado de Google Cloud Storage: {file_path}\")\n            return True\n        else:\n            st.warning(\n                f\"El archivo no existe en Google Cloud Storage: {file_path}\")\n            return True  # Consideramos esto como éxito ya que el objetivo es que no exista\n\n    except Exception as e:\n        st.error(\n            f\"Error al eliminar archivo de Google Cloud Storage: {str(e)}\")\n        st.error(f\"URL problemática: {file_url}\")\n        st.error(\n            f\"Path extraído: {file_path if 'file_path' in locals() else 'No se pudo extraer'}\"\n        )\n        return False\n\n\n# Agrega esta función temporal a tu código para ver qué buckets existen\ndef debug_list_buckets(gcs_client):\n    \"\"\"Lista todos los buckets disponibles en el proyecto\"\"\"\n    try:\n        buckets = list(gcs_client.list_buckets())\n        st.write(\"### Buckets disponibles en el proyecto:\")\n        if buckets:\n            for bucket in buckets:\n                st.write(f\"- {bucket.name}\")\n                st.write(f\"  Ubicación: {bucket.location}\")\n                st.write(f\"  Clase de almacenamiento: {bucket.storage_class}\")\n                st.write(\"---\")\n        else:\n            st.write(\"No se encontraron buckets en el proyecto\")\n\n        # Información del proyecto\n        st.write(f\"**Proyecto actual:** {gcs_client.project}\")\n\n    except Exception as e:\n        st.error(f\"Error al listar buckets: {str(e)}\")\n\n\n# Llama a esta función en tu main() para debug:\n# En la función donde inicializas gcs_client, agrega:\n# debug_list_buckets(gcs_client)\n\n\n# Función mejorada para eliminar evidencia de Google Sheets\ndef delete_evidencia(client, evidencia_data):\n    \"\"\"Elimina una evidencia específica de Google Sheets usando un identificador único\"\"\"\n    try:\n        sheet = client.open(\"sistema_evidencias\")\n        evidencias_worksheet = sheet.worksheet(\"evidencias\")\n\n        # Obtener todos los registros\n        all_records = evidencias_worksheet.get_all_records()\n\n        # Buscar la fila que coincida con todos los campos\n        for i, record in enumerate(all_records):\n            match = True\n            for key, value in evidencia_data.items():\n                if str(record.get(key, '')).strip() != str(value).strip():\n                    match = False\n                    break\n\n            if match:\n                # Eliminar la fila (i + 2 porque las filas empiezan en 1 y hay encabezado)\n                evidencias_worksheet.delete_rows(i + 2)\n\n                # Limpiar cache\n                get_evidencias_data.clear()\n\n                st.success(\"Evidencia eliminada de la base de datos\")\n                return True\n\n        st.error(\n            \"No se encontró la evidencia para eliminar en la base de datos\")\n        return False\n\n    except Exception as e:\n        st.error(f\"Error al eliminar evidencia de la base de datos: {str(e)}\")\n        return False\n\n\n# Función para eliminar múltiples archivos (nueva funcionalidad)\ndef delete_multiple_files(selected_files, client, gcs_client):\n    \"\"\"Elimina múltiples archivos seleccionados\"\"\"\n    if not selected_files:\n        st.warning(\"No hay archivos seleccionados para eliminar\")\n        return\n\n    success_count = 0\n    error_count = 0\n\n    progress_bar = st.progress(0)\n    total_files = len(selected_files)\n\n    for i, file_data in enumerate(selected_files):\n        progress_bar.progress((i + 1) / total_files)\n\n        with st.spinner(\n                f\"Eliminando {file_data.get('nombre_archivo', 'archivo')}...\"):\n            # Eliminar de Google Sheets\n            sheets_success = delete_evidencia(client, file_data)\n\n            # Eliminar de Google Cloud Storage\n            gcs_success = True\n            if file_data.get('url_cloudinary'):\n                gcs_success = delete_from_gcs(file_data['url_cloudinary'],\n                                              gcs_client)\n\n            if sheets_success and gcs_success:\n                success_count += 1\n            else:\n                error_count += 1\n\n    if success_count > 0:\n        st.success(f\"✅ {success_count} archivo(s) eliminado(s) exitosamente\")\n\n    if error_count > 0:\n        st.error(\n            f\"❌ {error_count} archivo(s) no pudieron ser eliminados completamente\"\n        )\n\n    progress_bar.empty()\n\n\n# Función para mostrar panel de usuario con eliminación mejorada\ndef show_user_panel():\n    \"\"\"Muestra el panel para usuarios regulares con funcionalidad de eliminación mejorada\"\"\"\n    user_data = st.session_state.user_data\n\n    st.title(f\"📋 Panel de Usuario - {user_data['programa']}\")\n    st.write(f\"Bienvenido, {user_data['correo']}\")\n\n    # Sidebar con información del usuario\n    with st.sidebar:\n        st.header(\"Información del Usuario\")\n        st.write(f\"**Correo:** {user_data['correo']}\")\n        st.write(f\"**Programa:** {user_data['programa']}\")\n        st.write(f\"**Rol:** {user_data['rol']}\")\n\n        if st.button(\"🔐 Cambiar Contraseña\"):\n            st.session_state.show_change_password = True\n            st.rerun()\n\n        if st.button(\"Cerrar Sesión\"):\n            for key in st.session_state.keys():\n                del st.session_state[key]\n            st.rerun()\n\n    # Verificar si se debe mostrar la página de cambio de contraseña\n    if st.session_state.get('show_change_password', False):\n        change_password_page()\n\n        if st.button(\"⬅️ Volver al Panel\"):\n            st.session_state.show_change_password = False\n            st.rerun()\n        return\n\n    # Inicializar servicios\n    client = init_google_sheets()\n    gcs_client = init_google_cloud_storage()\n\n    if not client or not gcs_client:\n        st.error(\"Error al inicializar los servicios necesarios\")\n        return\n\n    # Tabs para organizar la interfaz\n    tab1, tab2 = st.tabs([\"📤 Subir Evidencia\", \"📋 Mis Evidencias\"])\n\n    with tab1:\n        st.header(\"Subir Evidencias por Criterios de Acreditación\")\n\n        # Selector de dimensión\n        dimension_seleccionada = st.selectbox(\n            \"Seleccione la Dimensión\",\n            list(CRITERIOS_ACREDITACION.keys()),\n            help=\"Seleccione la dimensión de acreditación correspondiente\")\n\n        # Selector de criterio basado en la dimensión\n        criterios_disponibles = list(\n            CRITERIOS_ACREDITACION[dimension_seleccionada].keys())\n        criterio_seleccionado = st.selectbox(\n            \"Seleccione el Criterio\",\n            criterios_disponibles,\n            help=\"Seleccione el criterio específico dentro de la dimensión\")\n\n        # Mostrar descripción del criterio\n        descripcion = CRITERIOS_ACREDITACION[dimension_seleccionada][\n            criterio_seleccionado]\n        st.info(f\"**Descripción:** {descripcion}\")\n\n        # Subida de múltiples archivos\n        uploaded_files = st.file_uploader(\n            f\"Seleccione los archivos para {criterio_seleccionado}\",\n            type=[\n                'pdf', 'jpg', 'jpeg', 'png', 'doc', 'docx', 'xls', 'xlsx',\n                'ppt', 'pptx'\n            ],\n            help=\"Formatos permitidos: PDF, imágenes, documentos de Office\",\n            accept_multiple_files=True)\n\n        if uploaded_files:\n            st.write(f\"**{len(uploaded_files)} archivo(s) seleccionado(s):**\")\n            for file in uploaded_files:\n                st.write(f\"• {file.name} ({file.size / 1024:.2f} KB)\")\n\n            if st.button(\"Subir Evidencias\", type=\"primary\"):\n                progress_bar = st.progress(0)\n                total_files = len(uploaded_files)\n\n                for i, uploaded_file in enumerate(uploaded_files):\n                    progress_bar.progress((i + 1) / total_files)\n\n                    with st.spinner(f\"Subiendo {uploaded_file.name}...\"):\n                        # Subir a Google Cloud Storage\n                        url_drive = upload_to_gcs(uploaded_file,\n                                                  user_data['programa'],\n                                                  gcs_client,\n                                                  dimension_seleccionada,\n                                                  criterio_seleccionado)\n\n                        if url_drive:\n                            # Registrar en Google Sheets\n                            success = add_evidencia(\n                                client, user_data['programa'],\n                                user_data['correo'], url_drive,\n                                criterio_seleccionado, dimension_seleccionada,\n                                uploaded_file.name)\n\n                            if success:\n                                st.success(\n                                    f\"✅ {uploaded_file.name} subido exitosamente!\"\n                                )\n                            else:\n                                st.error(\n                                    f\"❌ Error al registrar {uploaded_file.name} en la base de datos\"\n                                )\n                        else:\n                            st.error(f\"❌ Error al subir {uploaded_file.name}\")\n\n                # Limpiar cache para mostrar datos actualizados\n                st.cache_data.clear()\n                st.balloons()\n                st.success(\n                    f\"🎉 Proceso completado! {total_files} archivo(s) procesado(s)\"\n                )\n\n    with tab2:\n        st.header(\"Mis Evidencias por Criterios\")\n\n        # Obtener evidencias del usuario\n        evidencias_df = get_evidencias_data(client)\n\n        if not evidencias_df.empty:\n            # Filtrar por programa del usuario\n            user_evidencias = evidencias_df[evidencias_df['programa'] ==\n                                            user_data['programa']]\n\n            if not user_evidencias.empty:\n                # Mostrar estadísticas\n                col1, col2 = st.columns(2)\n                with col1:\n                    st.metric(\"Total de Evidencias\", len(user_evidencias))\n\n                # Verificar si existen las nuevas columnas\n                if 'criterio' in user_evidencias.columns and 'dimension' in user_evidencias.columns:\n                    with col2:\n                        criterios_unicos = int(\n                            pd.Series(user_evidencias['criterio']).nunique())\n                        st.metric(\"Criterios Cubiertos\", criterios_unicos)\n\n                    # Selector de filtro por dimensión\n                    st.subheader(\"🔍 Filtrar por Dimensión\")\n                    dimensiones_disponibles = ['Todas'] + sorted(\n                        pd.Series(\n                            user_evidencias['dimension']).unique().tolist())\n                    dimension_filtro = st.selectbox(\"Filtrar por Dimensión\",\n                                                    dimensiones_disponibles)\n\n                    # Aplicar filtro\n                    df_mostrar = user_evidencias.copy()\n                    if dimension_filtro != 'Todas':\n                        df_mostrar = df_mostrar[df_mostrar['dimension'] ==\n                                                dimension_filtro]\n\n                    # Opción de eliminación múltiple\n                    st.subheader(\"🗑️ Eliminación de Archivos\")\n\n                    # Checkbox para seleccionar modo de eliminación múltiple\n                    multiple_delete_mode = st.checkbox(\n                        \"Modo eliminación múltiple\")\n\n                    if multiple_delete_mode:\n                        st.info(\n                            \"Seleccione los archivos que desea eliminar y use el botón 'Eliminar Seleccionados'\"\n                        )\n\n                        # Crear lista de archivos para selección múltiple\n                        files_to_select = []\n                        selected_files = []\n\n                        for idx, row in df_mostrar.iterrows():\n                            file_info = {\n                                'nombre_archivo':\n                                row.get('nombre_archivo', 'Sin nombre'),\n                                'criterio':\n                                row.get('criterio', ''),\n                                'fecha_hora':\n                                row.get('fecha_hora', ''),\n                                'programa':\n                                row.get('programa', user_data['programa']),\n                                'subido_por':\n                                row.get('subido_por', user_data['correo']),\n                                'url_cloudinary':\n                                row.get('url_cloudinary', ''),\n                                'dimension':\n                                row.get('dimension', '')\n                            }\n\n                            file_display_name = f\"{file_info['nombre_archivo']} - {file_info['criterio']} ({file_info['fecha_hora']})\"\n\n                            if st.checkbox(file_display_name,\n                                           key=f\"select_file_{idx}\"):\n                                selected_files.append(file_info)\n\n                        # Botón para eliminar archivos seleccionados\n                        col1, col2 = st.columns([1, 3])\n                        with col1:\n                            if st.button(\"🗑️ Eliminar Seleccionados\",\n                                         type=\"primary\",\n                                         disabled=len(selected_files) == 0):\n                                if selected_files:\n                                    st.session_state[\n                                        'confirm_delete_multiple'] = selected_files\n                                    st.rerun()\n\n                        with col2:\n                            if selected_files:\n                                st.info(\n                                    f\"{len(selected_files)} archivo(s) seleccionado(s)\"\n                                )\n\n                        # Confirmación de eliminación múltiple\n                        if st.session_state.get('confirm_delete_multiple'):\n                            files_to_delete = st.session_state[\n                                'confirm_delete_multiple']\n                            st.error(\n                                f\"¿Estás seguro de eliminar {len(files_to_delete)} archivo(s)?\"\n                            )\n\n                            col_yes, col_no = st.columns(2)\n                            with col_yes:\n                                if st.button(\"✅ Sí, eliminar todos\",\n                                             key=\"confirm_multiple_yes\"):\n                                    delete_multiple_files(\n                                        files_to_delete, client, gcs_client)\n                                    del st.session_state[\n                                        'confirm_delete_multiple']\n                                    st.rerun()\n\n                            with col_no:\n                                if st.button(\"❌ Cancelar\",\n                                             key=\"confirm_multiple_no\"):\n                                    del st.session_state[\n                                        'confirm_delete_multiple']\n                                    st.rerun()\n\n                    # Mostrar evidencias agrupadas por criterio\n                    st.subheader(\"📋 Evidencias por Criterio\")\n\n                    if len(df_mostrar) > 0:\n                        for criterio in sorted(\n                                pd.Series(df_mostrar['criterio']).unique()):\n                            criterio_evidencias = df_mostrar[\n                                df_mostrar['criterio'] == criterio]\n\n                            # Mantener estado del expander usando session_state\n                            expander_key = f\"expander_{criterio.replace(' ', '_').replace('.', '_')}\"\n                            if expander_key not in st.session_state:\n                                st.session_state[expander_key] = False\n\n                            # Verificar si hay alguna confirmación pendiente para este criterio\n                            has_pending_confirmation = False\n                            for idx, row in criterio_evidencias.iterrows():\n                                file_name = row.get('nombre_archivo',\n                                                    'archivo')\n                                unique_key = f\"{row.get('programa', user_data['programa'])}_{row.get('subido_por', user_data['correo'])}_{file_name}_{idx}\".replace(\n                                    \" \", \"_\").replace(\"/\",\n                                                      \"_\").replace(\".\", \"_\")\n                                if st.session_state.get(\n                                        f'confirm_delete_{unique_key}'):\n                                    has_pending_confirmation = True\n                                    st.session_state[expander_key] = True\n                                    break\n\n                            with st.expander(\n                                    f\"{criterio} ({len(criterio_evidencias)} archivo(s))\",\n                                    expanded=st.session_state[expander_key]):\n                                # Mostrar tabla para este criterio\n                                columns_to_show = [\n                                    'nombre_archivo', 'fecha_hora',\n                                    'url_cloudinary'\n                                ]\n                                available_columns = [\n                                    col for col in columns_to_show\n                                    if col in criterio_evidencias.columns\n                                ]\n\n                                if 'nombre_archivo' not in criterio_evidencias.columns:\n                                    available_columns = [\n                                        'fecha_hora', 'url_cloudinary'\n                                    ]\n\n                                st.dataframe(\n                                    criterio_evidencias[available_columns],\n                                    column_config={\n                                        'nombre_archivo':\n                                        'Nombre del Archivo',\n                                        'fecha_hora':\n                                        'Fecha y Hora',\n                                        'url_cloudinary':\n                                        st.column_config.LinkColumn(\n                                            'Enlace al Archivo',\n                                            display_text=\"Ver Archivo\")\n                                    },\n                                    use_container_width=True,\n                                    hide_index=True)\n\n                                # Solo mostrar botones individuales si no está en modo eliminación múltiple\n                                if not multiple_delete_mode:\n                                    st.subheader(\"🔧 Acciones Individuales\")\n\n                                    for idx, row in criterio_evidencias.iterrows(\n                                    ):\n                                        file_name = row.get(\n                                            'nombre_archivo', 'archivo')\n                                        file_url = row.get(\n                                            'url_cloudinary', '')\n\n                                        # Crear datos completos para eliminación\n                                        evidencia_data = {\n                                            'programa':\n                                            row.get('programa',\n                                                    user_data['programa']),\n                                            'subido_por':\n                                            row.get('subido_por',\n                                                    user_data['correo']),\n                                            'url_cloudinary':\n                                            file_url,\n                                            'criterio':\n                                            row.get('criterio', ''),\n                                            'dimension':\n                                            row.get('dimension', ''),\n                                            'nombre_archivo':\n                                            file_name\n                                        }\n\n                                        # Crear key único basado en el contenido del archivo\n                                        unique_key = f\"{evidencia_data['programa']}_{evidencia_data['subido_por']}_{file_name}_{idx}\".replace(\n                                            \" \", \"_\").replace(\"/\",\n                                                              \"_\").replace(\n                                                                  \".\", \"_\")\n\n                                        # Contenedor para cada archivo\n                                        file_container = st.container()\n\n                                        with file_container:\n                                            col_file, col_delete = st.columns(\n                                                [3, 1])\n\n                                            with col_file:\n                                                st.write(f\"📄 {file_name}\")\n\n                                            with col_delete:\n                                                if st.button(\n                                                        f\"🗑️\",\n                                                        key=\n                                                        f\"delete_{unique_key}\",\n                                                        help=\"Eliminar archivo\"\n                                                ):\n                                                    st.session_state[\n                                                        f'confirm_delete_{unique_key}'] = evidencia_data\n                                                    # Mantener el expander abierto\n                                                    st.session_state[\n                                                        expander_key] = True\n                                                    st.rerun()\n\n                                            # Confirmación de eliminación individual\n                                            if st.session_state.get(\n                                                    f'confirm_delete_{unique_key}'\n                                            ):\n                                                delete_info = st.session_state[\n                                                    f'confirm_delete_{unique_key}']\n\n                                                st.warning(\n                                                    f\"¿Estás seguro de eliminar **{delete_info['nombre_archivo']}**?\"\n                                                )\n                                                st.info(\n                                                    \"Esta acción no se puede deshacer.\"\n                                                )\n\n                                                col_yes, col_no = st.columns(2)\n\n                                                with col_yes:\n                                                    if st.button(\n                                                            \"✅ Sí, eliminar\",\n                                                            key=\n                                                            f\"confirm_yes_{unique_key}\",\n                                                            type=\"primary\"):\n                                                        with st.spinner(\n                                                                f\"Eliminando {delete_info['nombre_archivo']}...\"\n                                                        ):\n                                                            # Eliminar de Google Sheets\n                                                            success_sheets = delete_evidencia(\n                                                                client,\n                                                                delete_info)\n\n                                                            # Eliminar de GCS\n                                                            success_gcs = True\n                                                            if delete_info[\n                                                                    'url_cloudinary']:\n                                                                success_gcs = delete_from_gcs(\n                                                                    delete_info[\n                                                                        'url_cloudinary'],\n                                                                    gcs_client)\n\n                                                            if success_sheets and success_gcs:\n                                                                st.success(\n                                                                    f\"✅ {delete_info['nombre_archivo']} eliminado exitosamente\"\n                                                                )\n                                                                # Mantener expander abierto después de eliminación exitosa\n                                                                st.session_state[\n                                                                    expander_key] = True\n                                                            elif success_sheets and not success_gcs:\n                                                                st.warning(\n                                                                    \"⚠️ Archivo eliminado de la base de datos, pero no del almacenamiento\"\n                                                                )\n                                                                st.session_state[\n                                                                    expander_key] = True\n                                                            else:\n                                                                st.error(\n                                                                    \"❌ Error al eliminar el archivo\"\n                                                                )\n                                                                st.session_state[\n                                                                    expander_key] = True\n\n                                                            # Limpiar confirmación\n                                                            del st.session_state[\n                                                                f'confirm_delete_{unique_key}']\n                                                            st.rerun()\n\n                                                with col_no:\n                                                    if st.button(\n                                                            \"❌ Cancelar\",\n                                                            key=\n                                                            f\"confirm_no_{unique_key}\"\n                                                    ):\n                                                        del st.session_state[\n                                                            f'confirm_delete_{unique_key}']\n                                                        # Mantener expander abierto al cancelar\n                                                        st.session_state[\n                                                            expander_key] = True\n                                                        st.rerun()\n\n                                                # Separador visual\n                                                st.divider()\n                    else:\n                        st.info(\n                            \"No hay evidencias para la dimensión seleccionada.\"\n                        )\n\n                else:\n                    # Formato antiguo - mostrar tabla simple con funcionalidad básica de eliminación\n                    st.warning(\n                        \"Algunas evidencias están en formato anterior. Funcionalidad de eliminación limitada.\"\n                    )\n                    columns_to_show = [\n                        'fecha_hora', 'subido_por', 'url_cloudinary'\n                    ]\n                    available_columns = [\n                        col for col in columns_to_show\n                        if col in user_evidencias.columns\n                    ]\n\n                    st.dataframe(user_evidencias[available_columns],\n                                 column_config={\n                                     'fecha_hora':\n                                     'Fecha y Hora',\n                                     'subido_por':\n                                     'Subido por',\n                                     'url_cloudinary':\n                                     st.column_config.LinkColumn(\n                                         'Enlace al Archivo',\n                                         display_text=\"Ver Archivo\")\n                                 },\n                                 use_container_width=True)\n\n                    # Botones de eliminación para formato antiguo\n                    st.subheader(\"🔧 Eliminar Archivos\")\n                    for idx, row in user_evidencias.iterrows():\n                        col1, col2 = st.columns([3, 1])\n                        with col1:\n                            st.write(\n                                f\"📄 Archivo del {row.get('fecha_hora', 'fecha desconocida')}\"\n                            )\n                        with col2:\n                            if st.button(f\"🗑️\", key=f\"delete_old_{idx}\"):\n                                evidencia_data = {\n                                    'programa':\n                                    row.get('programa', user_data['programa']),\n                                    'subido_por':\n                                    row.get('subido_por', user_data['correo']),\n                                    'url_cloudinary':\n                                    row.get('url_cloudinary', ''),\n                                    'fecha_hora':\n                                    row.get('fecha_hora', '')\n                                }\n                                st.session_state[\n                                    f'confirm_delete_old_{idx}'] = evidencia_data\n                                st.rerun()\n\n                        # Confirmación para formato antiguo\n                        if st.session_state.get(f'confirm_delete_old_{idx}'):\n                            delete_info = st.session_state[\n                                f'confirm_delete_old_{idx}']\n                            st.warning(\n                                f\"¿Eliminar archivo del {delete_info.get('fecha_hora', 'fecha desconocida')}?\"\n                            )\n                            col_yes, col_no = st.columns(2)\n\n                            with col_yes:\n                                if st.button(\"✅ Sí\",\n                                             key=f\"confirm_old_yes_{idx}\"):\n                                    with st.spinner(\"Eliminando archivo...\"):\n                                        success_sheets = delete_evidencia(\n                                            client, delete_info)\n                                        success_gcs = True\n\n                                        if delete_info.get('url_cloudinary'):\n                                            success_gcs = delete_from_gcs(\n                                                delete_info['url_cloudinary'],\n                                                gcs_client)\n\n                                        if success_sheets and success_gcs:\n                                            st.success(\n                                                \"✅ Archivo eliminado exitosamente\"\n                                            )\n                                        else:\n                                            st.error(\n                                                \"❌ Error al eliminar el archivo\"\n                                            )\n\n                                        del st.session_state[\n                                            f'confirm_delete_old_{idx}']\n                                        st.rerun()\n\n                            with col_no:\n                                if st.button(\"❌ No\",\n                                             key=f\"confirm_old_no_{idx}\"):\n                                    del st.session_state[\n                                        f'confirm_delete_old_{idx}']\n                                    st.rerun()\n            else:\n                st.info(\"No hay evidencias registradas para tu programa aún.\")\n        else:\n            st.info(\"No se pudieron cargar las evidencias.\")\n\n\n# Función para mostrar panel de admin con eliminación mejorada\ndef show_admin_panel():\n    \"\"\"Muestra el panel para administradores con funcionalidad de eliminación\"\"\"\n    user_data = st.session_state.user_data\n\n    st.title(\"👨‍💼 Panel de Administrador\")\n    st.write(f\"Bienvenido, {user_data['correo']}\")\n\n    # Sidebar con información del usuario\n    with st.sidebar:\n        st.header(\"Información del Usuario\")\n        st.write(f\"**Correo:** {user_data['correo']}\")\n        st.write(f\"**Programa:** {user_data['programa']}\")\n        st.write(f\"**Rol:** {user_data['rol']}\")\n\n        if st.button(\"🔐 Cambiar Contraseña\", key=\"admin_change_password\"):\n            st.session_state.show_change_password = True\n            st.rerun()\n\n        if st.button(\"Cerrar Sesión\"):\n            for key in st.session_state.keys():\n                del st.session_state[key]\n            st.rerun()\n\n    # Verificar si se debe mostrar la página de cambio de contraseña\n    if st.session_state.get('show_change_password', False):\n        change_password_page()\n\n        if st.button(\"⬅️ Volver al Panel\", key=\"admin_back_to_panel\"):\n            st.session_state.show_change_password = False\n            st.rerun()\n        return\n\n    # Inicializar servicios\n    client = init_google_sheets()\n    gcs_client = init_google_cloud_storage()\n\n    if not client:\n        st.error(\"Error al inicializar Google Sheets\")\n        return\n\n    # Obtener datos\n    evidencias_df = get_evidencias_data(client)\n    users_df = get_users_data(client)\n\n    if evidencias_df.empty:\n        st.info(\"No hay evidencias registradas en el sistema.\")\n        return\n\n    # Estadísticas generales\n    st.header(\"📊 Resumen General\")\n\n    col1, col2, col3, col4 = st.columns(4)\n\n    with col1:\n        st.metric(\"Total Evidencias\", len(evidencias_df))\n\n    with col2:\n        unique_programs = int(evidencias_df['programa'].nunique())\n        st.metric(\"Programas Activos\", unique_programs)\n\n    with col3:\n        unique_users = int(evidencias_df['subido_por'].nunique())\n        st.metric(\"Usuarios Activos\", unique_users)\n\n    with col4:\n        # Evidencias del último mes\n        today = datetime.now()\n        evidencias_df['fecha_hora'] = pd.to_datetime(\n            evidencias_df['fecha_hora'], errors='coerce')\n        recent_evidencias = evidencias_df[evidencias_df['fecha_hora'] > (\n            today - pd.Timedelta(days=30))]\n        st.metric(\"Evidencias (30 días)\", len(recent_evidencias))\n\n    # Pestañas para organizar funcionalidades de admin\n    tab1, tab2 = st.tabs([\"📋 Visualizar Evidencias\", \"🗑️ Gestión de Archivos\"])\n\n    with tab1:\n        # Filtros\n        st.header(\"🔍 Filtrar Evidencias\")\n\n        # Verificar si existen las nuevas columnas\n        has_new_columns = 'criterio' in evidencias_df.columns and 'dimension' in evidencias_df.columns\n\n        if has_new_columns:\n            col1, col2, col3 = st.columns(3)\n\n            with col1:\n                # Filtro por programa\n                programas_disponibles = ['Todos'] + sorted(\n                    evidencias_df['programa'].unique().tolist())\n                programa_seleccionado = st.selectbox(\"Filtrar por Programa\",\n                                                     programas_disponibles)\n\n            with col2:\n                # Filtro por dimensión\n                dimensiones_disponibles = ['Todas'] + sorted(\n                    pd.Series(evidencias_df['dimension']).unique().tolist())\n                dimension_seleccionada = st.selectbox(\"Filtrar por Dimensión\",\n                                                      dimensiones_disponibles)\n\n            with col3:\n                # Filtro por criterio\n                if dimension_seleccionada != 'Todas':\n                    criterios_filtrados = pd.Series(evidencias_df[\n                        evidencias_df['dimension'] == dimension_seleccionada]\n                                                    ['criterio']).unique()\n                    criterios_disponibles = ['Todos'] + sorted(\n                        criterios_filtrados.tolist())\n                else:\n                    criterios_disponibles = ['Todos'] + sorted(\n                        pd.Series(evidencias_df['criterio']).unique().tolist())\n                criterio_seleccionado = st.selectbox(\"Filtrar por Criterio\",\n                                                     criterios_disponibles)\n        else:\n            col1, col2 = st.columns(2)\n\n            with col1:\n                # Filtro por programa\n                programas_disponibles = ['Todos'] + sorted(\n                    evidencias_df['programa'].unique().tolist())\n                programa_seleccionado = st.selectbox(\"Filtrar por Programa\",\n                                                     programas_disponibles)\n\n            with col2:\n                dimension_seleccionada = 'Todas'\n                criterio_seleccionado = 'Todos'\n\n        # Filtro por fecha\n        st.subheader(\"📅 Filtrar por Fecha\")\n        col1, col2 = st.columns(2)\n        with col1:\n            fecha_desde = st.date_input(\"Desde\",\n                                        value=(today.date() -\n                                               pd.Timedelta(days=30)))\n        with col2:\n            fecha_hasta = st.date_input(\"Hasta\", value=today.date())\n\n        # Aplicar filtros\n        df_filtrado = evidencias_df.copy()\n\n        if programa_seleccionado != 'Todos':\n            df_filtrado = df_filtrado[df_filtrado['programa'] ==\n                                      programa_seleccionado]\n\n        if has_new_columns:\n            if dimension_seleccionada != 'Todas':\n                df_filtrado = df_filtrado[df_filtrado['dimension'] ==\n                                          dimension_seleccionada]\n\n            if criterio_seleccionado != 'Todos':\n                df_filtrado = df_filtrado[df_filtrado['criterio'] ==\n                                          criterio_seleccionado]\n\n        # Filtrar por fecha\n        if len(df_filtrado) > 0 and 'fecha_hora' in df_filtrado.columns:\n            fecha_serie = pd.to_datetime(df_filtrado['fecha_hora'],\n                                         errors='coerce')\n            df_filtrado = df_filtrado[(fecha_serie.dt.date >= fecha_desde)\n                                      & (fecha_serie.dt.date <= fecha_hasta)]\n\n        # Mostrar resultados\n        st.header(\"📋 Evidencias Filtradas\")\n\n        if len(df_filtrado) > 0:\n            st.write(f\"Mostrando {len(df_filtrado)} evidencias\")\n\n            # Determinar columnas a mostrar basándose en las disponibles\n            if has_new_columns and 'nombre_archivo' in df_filtrado.columns:\n                columns_to_show = [\n                    'programa', 'criterio', 'nombre_archivo', 'subido_por',\n                    'fecha_hora', 'url_cloudinary'\n                ]\n                column_config = {\n                    'programa':\n                    'Programa',\n                    'criterio':\n                    'Criterio',\n                    'nombre_archivo':\n                    'Nombre del Archivo',\n                    'subido_por':\n                    'Subido por',\n                    'fecha_hora':\n                    'Fecha y Hora',\n                    'url_cloudinary':\n                    st.column_config.LinkColumn('Enlace al Archivo',\n                                                display_text=\"Ver Archivo\")\n                }\n            else:\n                # Formato anterior o columnas limitadas\n                columns_to_show = [\n                    'programa', 'subido_por', 'fecha_hora', 'url_cloudinary'\n                ]\n                column_config = {\n                    'programa':\n                    'Programa',\n                    'subido_por':\n                    'Subido por',\n                    'fecha_hora':\n                    'Fecha y Hora',\n                    'url_cloudinary':\n                    st.column_config.LinkColumn('Enlace al Archivo',\n                                                display_text=\"Ver Archivo\")\n                }\n\n            # Filtrar solo las columnas que existen\n            available_columns = [\n                col for col in columns_to_show if col in df_filtrado.columns\n            ]\n\n            # Tabla con todas las evidencias\n            st.dataframe(df_filtrado[available_columns],\n                         column_config=column_config,\n                         use_container_width=True)\n\n            # Gráficos de distribución\n            col1, col2 = st.columns(2)\n\n            with col1:\n                st.subheader(\"📈 Distribución por Programa\")\n                programa_counts = pd.Series(\n                    df_filtrado['programa']).value_counts()\n                st.bar_chart(programa_counts)\n\n            if has_new_columns:\n                with col2:\n                    st.subheader(\"📊 Distribución por Criterio\")\n                    criterio_counts = pd.Series(\n                        df_filtrado['criterio']).value_counts()\n                    st.bar_chart(criterio_counts)\n        else:\n            st.info(\"No se encontraron evidencias con los filtros aplicados.\")\n\n    with tab2:\n        st.header(\"🗑️ Gestión de Archivos (Solo Administradores)\")\n        st.warning(\n            \"⚠️ Esta sección permite eliminar archivos de cualquier programa. Use con precaución.\"\n        )\n\n        if gcs_client:\n            # Mostrar funcionalidad de eliminación para administradores\n            admin_delete_mode = st.checkbox(\n                \"Activar modo eliminación de administrador\")\n\n            if admin_delete_mode:\n                st.error(\n                    \"🔴 MODO ELIMINACIÓN ACTIVO - Los cambios son irreversibles\"\n                )\n\n                # Selector de evidencias para eliminar\n                if len(evidencias_df) > 0:\n                    # Crear lista de archivos para selección múltiple por administrador\n                    selected_admin_files = []\n\n                    st.subheader(\"Seleccionar archivos para eliminar:\")\n\n                    # Agrupar por programa para mejor organización\n                    for programa in sorted(evidencias_df['programa'].unique()):\n                        with st.expander(f\"📁 {programa}\"):\n                            programa_files = evidencias_df[\n                                evidencias_df['programa'] == programa]\n\n                            for idx, row in programa_files.iterrows():\n                                file_info = {\n                                    'programa':\n                                    row.get('programa', ''),\n                                    'subido_por':\n                                    row.get('subido_por', ''),\n                                    'url_cloudinary':\n                                    row.get('url_cloudinary', ''),\n                                    'fecha_hora':\n                                    row.get('fecha_hora', ''),\n                                    'criterio':\n                                    row.get('criterio', ''),\n                                    'dimension':\n                                    row.get('dimension', ''),\n                                    'nombre_archivo':\n                                    row.get('nombre_archivo', 'Sin nombre')\n                                }\n\n                                file_display = f\"{file_info['nombre_archivo']} - {file_info['subido_por']} ({file_info['fecha_hora']})\"\n\n                                if st.checkbox(file_display,\n                                               key=f\"admin_select_{idx}\"):\n                                    selected_admin_files.append(file_info)\n\n                    # Botón de eliminación para administrador\n                    if selected_admin_files:\n                        st.error(\n                            f\"⚠️ {len(selected_admin_files)} archivo(s) seleccionado(s) para eliminación\"\n                        )\n\n                        if st.button(\"🗑️ ELIMINAR ARCHIVOS SELECCIONADOS\",\n                                     type=\"primary\"):\n                            st.session_state[\n                                'admin_confirm_delete'] = selected_admin_files\n                            st.rerun()\n\n                        # Confirmación de eliminación de administrador\n                        if st.session_state.get('admin_confirm_delete'):\n                            files_to_delete = st.session_state[\n                                'admin_confirm_delete']\n                            st.error(\n                                f\"🚨 CONFIRMACIÓN REQUERIDA: ¿Eliminar {len(files_to_delete)} archivo(s)?\"\n                            )\n                            st.write(\"Esta acción NO se puede deshacer.\")\n\n                            col_confirm, col_cancel = st.columns(2)\n\n                            with col_confirm:\n                                if st.button(\"✅ CONFIRMAR ELIMINACIÓN\",\n                                             key=\"admin_confirm_yes\"):\n                                    delete_multiple_files(\n                                        files_to_delete, client, gcs_client)\n                                    del st.session_state[\n                                        'admin_confirm_delete']\n                                    st.rerun()\n\n                            with col_cancel:\n                                if st.button(\"❌ CANCELAR\",\n                                             key=\"admin_confirm_no\"):\n                                    del st.session_state[\n                                        'admin_confirm_delete']\n                                    st.rerun()\n                else:\n                    st.info(\"No hay archivos para gestionar\")\n        else:\n            st.error(\"Error al conectar con el sistema de almacenamiento\")\n\n\n# Función principal\ndef main():\n    \"\"\"Función principal de la aplicación\"\"\"\n\n    # Inicializar session state\n    if 'logged_in' not in st.session_state:\n        st.session_state.logged_in = False\n\n    # Verificar si el usuario está logueado\n    if not st.session_state.logged_in:\n        show_login()\n    else:\n        # Mostrar panel según el rol\n        user_role = st.session_state.user_data.get('rol', '')\n\n        if user_role == 'admin':\n            show_admin_panel()\n        elif user_role == 'usuario':\n            show_user_panel()\n        else:\n            st.error(\"Rol de usuario no reconocido\")\n            # Limpiar session state\n            for key in st.session_state.keys():\n                del st.session_state[key]\n            st.rerun()\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":70977},"pyproject.toml":{"content":"[project]\nname = \"sistema-evidencias\"\nversion = \"1.0.0\"\ndescription = \"Sistema de gestión de evidencias para acreditación.\"\nrequires-python = \">=3.9\"\n\ndependencies = [\n    \"streamlit\",\n    \"gspread\",\n    \"google-auth\",            # Nombre correcto para la autenticación base\n    \"google-auth-oauthlib\",   # Requerido por gspread\n    \"google-cloud-storage\",\n    \"pandas\",\n]\n[tool.poetry]\npackage-mode = false","size_bytes":410},"replit.md":{"content":"# Overview\n\nThis is a university accreditation evidence management system built with Streamlit. The application allows users to upload, store, and manage academic evidence files based on their role and program affiliation. It features role-based access control where regular users can only manage evidence for their own program, while administrators have access to all programs with filtering capabilities.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Architecture\n- **Framework**: Streamlit-based web application with a single-page architecture\n- **Layout**: Wide layout configuration for better content display\n- **Session Management**: Uses `st.session_state` for maintaining user authentication across page interactions\n- **UI Components**: Form-based login, file upload interface, and admin dashboard with filtering capabilities\n\n## Backend Architecture\n- **Structure**: Monolithic architecture contained in a single `main.py` file\n- **Authentication System**: Email-based login validation against Google Sheets user database\n- **Role-Based Access Control**: Two-tier system with \"usuario\" (user) and \"admin\" roles implementing row-level security\n- **File Processing**: Direct file upload handling with metadata extraction\n\n## Data Storage Solutions\n- **Primary Database**: Google Sheets acting as the main data store with two worksheets:\n  - \"usuarios\" worksheet: Contains user data (correo, programa, rol)\n  - \"evidencias\" worksheet: Stores evidence records (programa, subido_por, url_cloudinary, fecha_hora)\n- **File Storage**: Cloudinary cloud service for storing uploaded files (PDFs, images, etc.)\n- **Caching**: Streamlit's `@st.cache_resource` decorator for optimizing Google Sheets connections\n\n## Authentication and Authorization\n- **Authentication Method**: Email-based validation against Google Sheets user database\n- **Session Management**: Streamlit session state for maintaining login status\n- **Authorization Logic**:\n  - Regular users: Can only view/upload evidence for their assigned program\n  - Admin users: Full access to all programs with filtering capabilities\n- **Security**: Row-level security implementation based on user program affiliation\n\n# External Dependencies\n\n## Cloud Services\n- **Google Sheets API**: Primary database for user management and evidence tracking\n- **Google Drive API**: Required for Google Sheets access permissions\n- **Cloudinary**: Cloud-based file storage and management service\n\n## Authentication Services\n- **Google OAuth2**: Service account authentication for Google Sheets access\n- **Google Service Account**: Credential management through JSON key files\n\n## API Integrations\n- **gspread**: Python library for Google Sheets API interaction\n- **google-auth**: OAuth2 authentication library for Google services\n- **cloudinary**: Python SDK for Cloudinary file upload and management\n\n## Configuration Management\n- **Replit Secrets**: Environment variable storage for sensitive credentials\n- **Environment Variables**:\n  - `GOOGLE_SHEETS_CREDENTIALS`: JSON service account credentials\n  - Cloudinary configuration (cloud_name, api_key, api_secret)","size_bytes":3174},"README.md":{"content":"# Sistema de Evidencias de Acreditación Universitaria\n\nUna aplicación web desarrollada con Streamlit para la gestión de evidencias académicas basada en criterios de acreditación universitaria.\n\n## Características\n\n- **Autenticación segura**: Login con email y contraseña almacenados en Google Sheets\n- **Gestión de roles**: Usuarios regulares y administradores con diferentes niveles de acceso\n- **Organización por criterios**: Sistema de 5 dimensiones y 14 criterios de acreditación\n- **Almacenamiento en la nube**: Archivos almacenados en Google Cloud Storage\n- **Base de datos**: Google Sheets como base de datos para usuarios y evidencias\n- **Interfaz intuitiva**: Filtros, métricas y visualizaciones\n\n## Tecnologías utilizadas\n\n- **Frontend**: Streamlit\n- **Almacenamiento**: Google Cloud Storage\n- **Base de datos**: Google Sheets API\n- **Autenticación**: Google OAuth2\n- **Lenguaje**: Python 3.11\n\n## Configuración\n\n### Variables de entorno requeridas\n\nEn Replit Secrets, configurar:\n\n- `GOOGLE_SHEETS_CREDENTIALS`: JSON con credenciales de service account de Google Sheets\n- `GOOGLE_APPLICATION_CREDENTIALS`: JSON con credenciales de Google Cloud Storage\n\n### Estructura de Google Sheets\n\nCrear una hoja llamada \"sistema_evidencias\" con dos pestañas:\n\n#### Pestaña \"usuarios\"\n```\ncorreo | programa | rol | contraseña\n```\n\n#### Pestaña \"evidencias\"  \n```\nprograma | subido_por | url_cloudinary | fecha_hora | criterio | dimension | nombre_archivo\n```\n\n## Instalación y ejecución\n\n1. Instalar dependencias:\n```bash\npip install streamlit gspread google-auth google-cloud-storage pandas\n```\n\n2. Configurar las credenciales de Google en los secrets\n\n3. Ejecutar la aplicación:\n```bash\nstreamlit run main.py --server.port 5000\n```\n\n## Funcionalidades\n\n### Para usuarios regulares:\n- Subir evidencias por criterios específicos\n- Ver sus propias evidencias organizadas por dimensión/criterio\n- Cambiar su contraseña\n- Eliminar archivos propios\n\n### Para administradores:\n- Ver todas las evidencias del sistema\n- Filtrar por programa, dimensión y criterio  \n- Análisis y métricas globales\n- Gestión completa de evidencias\n\n## Estructura del proyecto\n\n```\n├── main.py              # Aplicación principal\n├── .streamlit/\n│   └── config.toml      # Configuración de Streamlit\n├── requirements.txt     # Dependencias Python\n└── README.md           # Documentación\n```\n\n## Contribución\n\nEste proyecto está diseñado para instituciones educativas que requieren un sistema de gestión de evidencias para procesos de acreditación.","size_bytes":2588}},"version":1}